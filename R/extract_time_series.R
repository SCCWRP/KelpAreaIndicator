#' Transform the quarterly landsat data to an annual time series
#'
#' @description The Landsat kelp area data is a quarterly product per pixel, so this function
#' serves to aggregate these pixels to a time series for each segment, either quarterly or
#' annually, with a few different methods for the annualization.
#'
#' @param segmented_landsat_data A dataframe generated by [KelpAreaIndicator::segment_landsat_data()]
#' with rows for each pixel, and columns for each quarter and year of the
#' landsat data, with the assigned segment from a given shapefile
#' @param ... unused
#' @param annualization_method The method used to convert the quarterly time series to an annual time
#' series.
#'  * "sum_first": sums together all quarterly area values for each pixel within each segment, and
#'  then the maximum area per year for each segment is calculated
#'  * "max_first": for each pixel, the maximum quarterly area in a year is calculated first, and
#'  then all these maximum areas per year are summed together within each kelp segment.
#'  * "Q1": selects the first quarter of every year
#'  * "Q2": selects the second quarter of every year
#'  * "Q3": selects the third quarter of every year
#'  * "Q4": selects the fourth quarter of every year
#' @param frequency The frequency of the time series to extract. Either "annual" (default) or "quarterly"
#' @param segment_id A character vector containing the subset of `segment_id`'s of interest, e.g.
#' `c("CA_71", "CA_78")`, or `NULL` for all segment IDs (default).
#' @export
#' @return A dataframe with the following columns:
#'
#'  * `Segment_ID`: The ID of the kelp area segment
#'  * `max_occupiable`: The maximum occupiable kelp area for the given segment. This column repeats
#'  the same value for all rows in a single kelp area segment
#'  * `historical_med`: The historical (1984-2013) median kelp area for the segment. The median is
#'  computed across the annualized kelp area values. This column repeats the same value for all rows
#'  in a single kelp area segment
#'  * `quarter`*: If `frequency == "quarterly"`, the quarter in the time series, otherwise not present
#'  * `year`: Year in the time series
#'  * `date`: date representation of the year/quarter, for simpler plotting
#'  * `area_abs`: Kelp area in absolute magnitude, in km^2
#'  * `area_hist`: Kelp area relative to the historical median, expressed as a percentage
#'  * `area_pct`: Kelp area relative to the maximum occupiable kelp area, expressed as a percentage
#'
#' @seealso [KelpAreaIndicator::get_max_occupiable_area()]
extract_time_series <- function(
    segmented_landsat_data,
    ...,
    frequency = c("annual", "quarterly"),
    annualization_method = c("sum_first", "max_first", "Q1", "Q2", "Q3", "Q4"),
    segment_id = NULL) {

  # if a segment_id or subset of segment_id's are specified, make sure
  # that they are all in the segmented_landsat_data
  if (!is.null(segment_id)) {
    if (!all(segment_id %in% segmented_landsat_data$Segment_ID)) {
      stop("not all values in `segment_id` are present in the segmented Landsat data")
    }
    segmented_landsat_data <- segmented_landsat_data |>
      dplyr::filter(Segment_ID %in% segment_id)
  }

  # check which time frequency to extract
  frequency <- rlang::arg_match(frequency)

  if (frequency == 'annual') {
    # check which method to use
    annualization_method <- rlang::arg_match(annualization_method)

    time_series <- extract_annual_time_series(
      segmented_landsat_data = segmented_landsat_data,
      annualization_method = annualization_method
    )
  } else {
    time_series <- extract_quarterly_time_series(
      segmented_landsat_data = segmented_landsat_data
    )
  }
  # calculate the maximum
  max_occupiable_kelp_area <- get_max_occupiable_area(segmented_landsat_data)

  # adding in the area relative to historical median and area relative
  # to max occupiable area metrics
  time_series <- time_series |>
    dplyr::left_join(max_occupiable_kelp_area, by = "Segment_ID") |>
    dplyr::group_by(Segment_ID) |>
    dplyr::mutate(
      historical_med = median(area_abs[dplyr::between(year, 1984, 2013)], na.rm = TRUE)
    ) |>
    dplyr::ungroup() |>
    dplyr::mutate(
      area_hist = area_abs / historical_med * 100,
      area_hist = ifelse(is.infinite(area_hist), NaN, area_hist),
      area_pct = area_abs / max_occupiable * 100
    ) |>
    dplyr::relocate(
      Segment_ID, max_occupiable, historical_med
    )

  time_series
}

extract_annual_time_series <- function(segmented_landsat_data, annualization_method) {
  # use the column names of the segmented_landsat_data dataframe to
  # extract the unique years for which we have data
  col_indices <- which(!(names(segmented_landsat_data) %in% c("Segment_ID", "lon", "lat")))
  years <- sapply(col_indices, function(x) {
    strsplit(names(segmented_landsat_data)[x], ".", fixed = TRUE)[[1]][2]
  }) |>
    as.numeric() |>
    unique() |>
    sort()

  if (annualization_method == "max_first") {
    annual_time_series <- do.call(cbind, lapply(years, function(y) {
      # for each year y in the years vector, select only the columns
      # for the current year
      current_year_data <- segmented_landsat_data |>
        dplyr::select(dplyr::ends_with(as.character(y)))

      # calculate maxima by row, i.e. max per year for each pixel
      do.call(function(...) pmax(..., na.rm = TRUE), current_year_data)
    })) |>
      as.data.frame()

    # rename the columns to the appropriate year
    names(annual_time_series) <- years

    # add back in the Segment_ID's
    annual_time_series$Segment_ID <- segmented_landsat_data$Segment_ID

    # convert to long format, get the sum of all the pixels in each segment per year
    annual_time_series <- annual_time_series |>
      tidyr::pivot_longer(cols = -Segment_ID, names_to = "year", names_transform = as.numeric) |>
      dplyr::group_by(Segment_ID, year) |>
      dplyr::summarize(area_abs = sum(value, na.rm = TRUE) / 1e6) # in km2
  }
  else if (annualization_method == "sum_first") {
    # first get the sum of all pixels in each segment for all quarters,
    # so that we have a quarterly time series for each segment,
    # then convert to long format, take the maximum per year for each
    # segment
    annual_time_series <- segmented_landsat_data |>
      dplyr::group_by(Segment_ID) |>
      dplyr::summarize(
        dplyr::across(
          .cols = dplyr::matches("Q[1-4]\\.[1-9]*"),
          .fns = function(x) sum(x, na.rm = TRUE)
        )
      ) |>
      tidyr::pivot_longer(
        cols = -Segment_ID, names_to = c("quarter", "year"), names_sep = "\\.",
        names_transform = list(quarter = as.character, year = as.numeric)
      ) |>
      dplyr::group_by(Segment_ID, year) |>
      dplyr::summarize(
        # max returns -Inf when the vector is all NA, so suppress this warning
        # and replace with NA later
        area_abs = suppressWarnings(max(value, na.rm = TRUE)) / 1e6 # in km2
      ) |>
      dplyr::mutate(
        area_abs = ifelse(is.infinite(area_abs), NA_real_, area_abs)
      )
  }
  else {
    # annualization_method %in% c("Q1", "Q2", "Q3", "Q4")
    annual_time_series <- segmented_landsat_data |>
      dplyr::group_by(Segment_ID) |>
      dplyr::summarize(
        dplyr::across(
          .cols = dplyr::matches("Q[1-4]\\.[1-9]*"),
          .fns = function(x) sum(x, na.rm = TRUE)
        )
      ) |>
      tidyr::pivot_longer(
        cols = -Segment_ID, names_to = c("quarter", "year"), names_sep = "\\.",
        names_transform = list(quarter = as.character, year = as.numeric),
        values_to = "area_abs"
      ) |>
      dplyr::mutate(
        area_abs = area_abs / 1e6 # in km2
      ) |>
      dplyr::filter(quarter == annualization_method)
  }

  annual_time_series <- annual_time_series |>
    dplyr::mutate(
      date = as.Date(paste0(year, "-01-01"))
    ) |>
    dplyr::relocate(Segment_ID, year, date)

  annual_time_series
}

extract_quarterly_time_series <- function(segmented_landsat_data) {
  quarterly_time_series <- segmented_landsat_data |>
    dplyr::group_by(Segment_ID) |>
    dplyr::summarize(dplyr::across(
      .cols = dplyr::matches("Q[1-4]\\.[1-9]*"),
      .fns = function(x) sum(x, na.rm = TRUE)
    )) |>
    tidyr::pivot_longer(
      cols = -Segment_ID, names_to = c("quarter", "year"), names_sep = "\\.",
      names_transform = list(quarter = as.character, year = as.numeric),
      values_to = "area_abs"
    ) |>
    dplyr::mutate(
      area_abs = area_abs / 1e6, # in km2
      date = dplyr::case_when(
        quarter == "Q1" ~ paste0(year, "-01-01"),
        quarter == "Q2" ~ paste0(year, "-04-01"),
        quarter == "Q3" ~ paste0(year, "-07-01"),
        quarter == "Q4" ~ paste0(year, "-10-01"),
      ),
      date = as.Date(date)
    ) |>
    dplyr::relocate(Segment_ID, quarter, year, date)

  quarterly_time_series
}
