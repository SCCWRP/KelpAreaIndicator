#' Transform the quarterly landsat data to an annual time series
#'
#' @description The landsat kelp area data is a quarterly product, so this function
#' serves to transform it to an annual product, with two separate options, described below.
#'
#' @param segmented_landsat_data dataframe generated by [KelpAreaIndicator::segment_landsat_data()]
#' with rows for each pixel, and columns for each quarter and year of the
#' landsat data, with the assigned segment from a given shapefile
#' @param ... unused
#' @param annualization_method The method used to convert the quarterly time series to an annual time
#' series.
#'
#'  * "max_first": for each pixel, the maximum quarterly area in a year is calculated first, and
#'  then all these maximum areas per year are summed together within each kelp segment.
#'  * "sum_first": sums together all quarterly area values for each pixel within each segment, and
#'  then the maximum area per year
#' for each segment is calculated
#'
#' @export
#' @return A dataframe with the following columns:
#'
#'  * `Segment_ID`: The ID of the kelp area segment
#'  * `max_occupiable`: The maximum occupiable kelp area for the given segment. This column repeats
#'  the same value for all rows in a single kelp area segment
#'  * `historical_med`: The historical (1984-2013) median kelp area for the segment. The median is
#'  computed across the maximum yearly kelp area. This column repeats the same value for all rows
#'  in a single kelp area segment
#'  * `year`: year of the time series
#'  * `area_abs`: kelp area in absolute magnitude, in km^2
#'  * `area_hist`: kelp area relative to the historical median, expressed as a percentage
#'  * `area_pct`: kelp area relative to the maximum occupiable kelp area, expressed as a percentage
#'
#' @seealso [KelpAreaIndicator::get_max_occupiable_area()]
annualize_time_series <- function(segmented_landsat_data, ..., annualization_method = c("max_first", "sum_first")) {
  # use the column names of the segmented_landsat_data dataframe to
  # extract the unique years for which we have data
  col_indices <- which(!(names(segmented_landsat_data) %in% c("Segment_ID", "lon", "lat")))
  years <- sapply(col_indices, function(x) {
    strsplit(names(segmented_landsat_data)[x], ".", fixed = TRUE)[[1]][2]
  }) |>
    as.numeric() |>
    unique() |>
    sort()

  # calculate the maximum
  max_occupiable_kelp_area <- get_max_occupiable_kelp_area(segmented_landsat_data)

  # check which method we're using
  annualization_method <- rlang::arg_match(annualization_method)

  if (annualization_method == "max_first") {
    # slower than a tidyverse solution, but conserves RAM
    annual_time_series <- do.call(cbind, lapply(years, function(y) {
      # for each year y in the years vector, select only the columns
      # for the current year
      current_year_data <- segmented_landsat_data |>
        dplyr::select(dplyr::ends_with(as.character(y)))

      # calculate maxima by row, i.e. max per year for each pixel
      apply(current_year_data, 1, function(x) {
        # if all NA in a year, returns -Inf, so replace with NA
        out <- suppressWarnings(max(x, na.rm = TRUE))
        out[is.infinite(out)] <- NA
        out
      })
    })) |>
      as.data.frame()

    # rename the columns to the appropriate year
    names(annual_time_series) <- years

    # add back in the Segment_ID's
    annual_time_series$Segment_ID <- segmented_landsat_data$Segment_ID

    # convert to long format, get the sum of all the pixels in each segment per year
    annual_time_series <- annual_time_series |>
      tidyr::pivot_longer(cols = -Segment_ID, names_to = "year", names_transform = as.numeric) |>
      dplyr::group_by(Segment_ID, year) |>
      dplyr::summarize(area_abs = sum(value, na.rm = TRUE) / 1e6) # in km2
  } else {
    # annualization_method == "sum_first"
    # first get the sum of all pixels in each segment for all quarters,
    # so that we have a quarterly time series for each segment,
    # then convert to long format, take the maximum per year for each
    # segment
    annual_time_series <- segmented_landsat_data |>
      dplyr::group_by(Segment_ID) |>
      dplyr::summarize(
        dplyr::across(
          .cols = dplyr::where(is.numeric),
          .fns = function(x) sum(x, na.rm = TRUE)
        )
      ) |>
      tidyr::pivot_longer(
        cols = -c(Segment_ID, lon, lat), names_to = c("quarter", "year"), names_sep = "\\.",
        names_transform = list(quarter = as.character, year = as.numeric)
      ) |>
      dplyr::group_by(Segment_ID, year) |>
      dplyr::summarize(
        # max returns -Inf when the vector is all NA, so suppress this warning
        # and replace with NA later
        area_abs = suppressWarnings(max(value, na.rm = TRUE)) / 1e6 # in km2
      ) |>
      dplyr::mutate(
        area_abs = ifelse(is.infinite(area_abs), NA_real_, area_abs)
      )
  }

  # adding in the area relative to historical median and area relative
  # to max occupiable area metrics
  annual_time_series |>
    dplyr::left_join(max_occupiable_kelp_area, by = "Segment_ID") |>
    dplyr::group_by(Segment_ID) |>
    dplyr::mutate(
      historical_med = median(area_abs[dplyr::between(year, 1984, 2013)], na.rm = TRUE)
    ) |>
    dplyr::ungroup() |>
    dplyr::mutate(
      area_hist = area_abs / historical_med * 100,
      area_hist = ifelse(is.infinite(area_hist), NaN, area_hist),
      area_pct = area_abs / max_occupiable * 100
    ) |>
    dplyr::select(
      Segment_ID, max_occupiable, historical_med,
      year, area_abs, area_hist, area_pct
    )
}
